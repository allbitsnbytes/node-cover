
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>/Users/itay/Work/mocha/node_modules/commander/lib/commander.js -- cover.io</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="bootstrap.css" rel="stylesheet">
    <link href="prettify.css" type="text/css" rel="stylesheet" />
    <style type="text/css">
      html, body {
        font-family: georgia, serif;
      }
      
      .content {
      }
      table#files-table {
        table-layout: fixed;
        width: 94%;
      }

      table#files-table td, table#files-table th {
        width: 11%;
        padding-left: 5px;
        padding-right: 5px;
      }
      
      table#files-table td:first-child, table#files-table th:first-child {
        width: 33%;
      }
        
      li.L0,li.L1,li.L2,li.L3,li.L4, li.L5,li.L6,li.L7,li.L8, li.L9 { background: transparent; }
      li.L1,li.L3,li.L5,li.L7,li.L9 { background: white; }
       
      li.covered {
        border-left: 2px solid lime; 
      }
      
      li.uncovered {
        background: #FDD;
        border-left: 2px solid red; 
      }
      
      li.partial {
        border-left: 2px solid #EE9; 
        background: #FFA;
      }
      
      .partialuncovered { 
        background: #EE9; 
      }
      
      ol.linenums { 
        font-size: 10px;
      }
      
      ol.linenums li  {
        line-height: 16px;
      }
      
      ol.linenums li span {
        font-size: 12px;
      }
      
      pre.prettyprint {
        padding-top: 1em;
        border: 5px;
        padding-left: 1.5em;
        padding-bottom: 2em;
        font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Liberation Mono', 'DejaVu Sans Mono', 'Bitstream Vera Sans Mono', 'Courier New', monospace, serif;

      }
      
      div.header {
        width: 100%;
        padding: 0;
        margin: 0;
        border-bottom: 1px solid #EEE;
        height: 90px;
        background: #F8F8F8;
      }
      
      div.header-content {
        padding: 1em 3em;
      }
      
      a.index {
        text-decoration: none;
        color: inherit;
        font-size: 11px;
      }
      
      a.coverio {
        text-decoration: none;
        color: inherit;
        font-size: 11px;
      }
      
      div.content > a.index {
        padding-left: 1.5em;
        padding-bottom: 2em;
      }
      
      div.header-content h3 {
        font-weight: normal;
      }
      
      span.filename {
        font-weight: bold;
      }
      
      span.percentage {
        font-weight: bold;
      }
      
      div.stats {
        font-size: 13px;
      }
      
      div.stats span.separator {
        margin-left: 10px;
        margin-right: 10px;
      }
      
      div.stats span.stat-descriptor {
        color: gray;
      }
      
    </style>

    <script src="jquery.min.js"></script>
    <script type="text/javascript" src="prettify.js"></script>
    <script >
      $(function() {
        prettyPrint();
        
        $("li span.covered").parent().addClass("covered");
        $("li span.uncovered").parent().addClass("uncovered");
        $("li span.partial").parent().addClass("partial");
      });
    </script>

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  </head>

  <body>

      <div class="content">
        <div class="header">
          <div class="header-content">
            <a class="index" href="index.html">Â« index</a>
            <h3>Coverage for <span class="filename">/Users/itay/Work/mocha/node_modules/commander/lib/commander.js</span> : <span class="percentage">85%</span></h3>
            <div class="stats">
              909  <span class="stat-descriptor">lines</span>     <span class="separator">| </span> 
              778  <span class="stat-descriptor">run</span>        <span class="separator">| </span> 
              131  <span class="stat-descriptor">missing</span>    <span class="separator">| </span> 
              5  <span class="stat-descriptor">partial</span>      <span class="separator">| </span> 
              259  <span class="stat-descriptor">blocks</span>     <span class="separator">| </span> 
              72  <span class="stat-descriptor">blocks run</span>  <span class="separator">| </span> 
              187  <span class="stat-descriptor">blocks missing</span>
            </div>
          </div>
        </div>
        <pre class='prettyprint lang-js linenums'>
<span class='covered'>  /*!</span>
<span class='covered'>   * commander</span>
<span class='covered'>   * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca></span>
<span class='covered'>   * MIT Licensed</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Module dependencies.</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  var EventEmitter = require('events').EventEmitter</span>
<span class='covered'>    , path = require('path')</span>
<span class='covered'>    , tty = require('tty')</span>
<span class='covered'>    , basename = path.basename;</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Expose the root command.</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  exports = module.exports = new Command;</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Expose `Command`.</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  exports.Command = Command;</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Expose `Option`.</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  exports.Option = Option;</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Initialize a new `Option` with the given `flags` and `description`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} flags</span>
<span class='covered'>   * @param {String} description</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  function Option(flags, description) {</span>
<span class='covered'>    this.flags = flags;</span>
<span class='covered'>    this.required = ~flags.indexOf('<');</span>
<span class='covered'>    this.optional = ~flags.indexOf('[');</span>
<span class='covered'>    this.bool = !~flags.indexOf('-no-');</span>
<span class='covered'>    flags = flags.split(/[ ,|]+/);</span>
<span class='partial'>    if (flags.length > 1 && !<span class='partialuncovered'>  /^[[&lt;]/.test(flags[1])</span>) this.short = flags.shift();</span>
<span class='covered'>    this.long = flags.shift();</span>
<span class='covered'>    this.description = description;</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Return option name.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @return {String}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Option.prototype.name = function(){</span>
<span class='covered'>    return this.long</span>
<span class='covered'>      .replace('--', '')</span>
<span class='covered'>      .replace('no-', '');</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Check if `arg` matches the short or long flag.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} arg</span>
<span class='covered'>   * @return {Boolean}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Option.prototype.is = function(arg){</span>
<span class='covered'>    return arg == this.short</span>
<span class='covered'>      || arg == this.long;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Initialize a new `Command`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} name</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  function Command(name) {</span>
<span class='covered'>    this.commands = [];</span>
<span class='covered'>    this.options = [];</span>
<span class='covered'>    this.args = [];</span>
<span class='covered'>    this.name = name;</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Inherit from `EventEmitter.prototype`.</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.__proto__ = EventEmitter.prototype;</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Add command `name`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * The `.action()` callback is invoked when the</span>
<span class='covered'>   * command `name` is specified via __ARGV__,</span>
<span class='covered'>   * and the remaining arguments are applied to the</span>
<span class='covered'>   * function for access.</span>
<span class='covered'>   *</span>
<span class='covered'>   * When the `name` is "*" an un-matched command</span>
<span class='covered'>   * will be passed as the first arg, followed by</span>
<span class='covered'>   * the rest of __ARGV__ remaining.</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *      program</span>
<span class='covered'>   *        .version('0.0.1')</span>
<span class='covered'>   *        .option('-C, --chdir <path>', 'change the working directory')</span>
<span class='covered'>   *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')</span>
<span class='covered'>   *        .option('-T, --no-tests', 'ignore test hook')</span>
<span class='covered'>   *     </span>
<span class='covered'>   *      program</span>
<span class='covered'>   *        .command('setup')</span>
<span class='covered'>   *        .description('run remote setup commands')</span>
<span class='covered'>   *        .action(function(){</span>
<span class='covered'>   *          console.log('setup');</span>
<span class='covered'>   *        });</span>
<span class='covered'>   *     </span>
<span class='covered'>   *      program</span>
<span class='covered'>   *        .command('exec <cmd>')</span>
<span class='covered'>   *        .description('run the given remote command')</span>
<span class='covered'>   *        .action(function(cmd){</span>
<span class='covered'>   *          console.log('exec "%s"', cmd);</span>
<span class='covered'>   *        });</span>
<span class='covered'>   *     </span>
<span class='covered'>   *      program</span>
<span class='covered'>   *        .command('*')</span>
<span class='covered'>   *        .description('deploy the given env')</span>
<span class='covered'>   *        .action(function(env){</span>
<span class='covered'>   *          console.log('deploying "%s"', env);</span>
<span class='covered'>   *        });</span>
<span class='covered'>   *     </span>
<span class='covered'>   *      program.parse(process.argv);</span>
<span class='covered'>    *</span>
<span class='covered'>   * @param {String} name</span>
<span class='covered'>   * @return {Command} the new command</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.command = function(name){</span>
<span class='uncovered'>    var args = name.split(/ +/);</span>
<span class='uncovered'>    var cmd = new Command(args.shift());</span>
<span class='uncovered'>    this.commands.push(cmd);</span>
<span class='uncovered'>    cmd.parseExpectedArgs(args);</span>
<span class='uncovered'>    cmd.parent = this;</span>
<span class='covered'>    return cmd;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Parse expected `args`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Array} args</span>
<span class='covered'>   * @return {Command} for chaining</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.parseExpectedArgs = function(args){</span>
<span class='uncovered'>    if (!args.length) return;</span>
<span class='uncovered'>    var self = this;</span>
<span class='uncovered'>    args.forEach(function(arg){</span>
<span class='uncovered'>      switch (arg[0]) {</span>
<span class='uncovered'>        case '&lt;':</span>
<span class='uncovered'>          self.args.push({ required: true, name: arg.slice(1, -1) });</span>
<span class='uncovered'>          break;</span>
<span class='uncovered'>        case '[':</span>
<span class='uncovered'>          self.args.push({ required: false, name: arg.slice(1, -1) });</span>
<span class='uncovered'>          break;</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>    });</span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Register callback `fn` for the command.</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *      program</span>
<span class='covered'>   *        .command('help')</span>
<span class='covered'>   *        .description('display verbose help')</span>
<span class='covered'>   *        .action(function(){</span>
<span class='covered'>   *           // output help here</span>
<span class='covered'>   *        });</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @return {Command} for chaining</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.action = function(fn){</span>
<span class='uncovered'>    var self = this;</span>
<span class='uncovered'>    this.parent.on(this.name, function(args){</span>
<span class='uncovered'>      self.args.forEach(function(arg, i){</span>
<span class='uncovered'>        if (arg.required && null == args[i]) {</span>
<span class='uncovered'>          self.missingArgument(arg.name);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      });</span>
<span class='uncovered'>      fn.apply(this, args);</span>
<span class='uncovered'>    });</span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Define option with `flags`, `description` and optional</span>
<span class='covered'>   * coercion `fn`. </span>
<span class='covered'>   *</span>
<span class='covered'>   * The `flags` string should contain both the short and long flags,</span>
<span class='covered'>   * separated by comma, a pipe or space. The following are all valid</span>
<span class='covered'>   * all will output this way when `--help` is used.</span>
<span class='covered'>   *</span>
<span class='covered'>   *    "-p, --pepper"</span>
<span class='covered'>   *    "-p|--pepper"</span>
<span class='covered'>   *    "-p --pepper"</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *     // simple boolean defaulting to false</span>
<span class='covered'>   *     program.option('-p, --pepper', 'add pepper');</span>
<span class='covered'>   *</span>
<span class='covered'>   *     --pepper</span>
<span class='covered'>   *     program.pepper</span>
<span class='covered'>   *     // => Boolean</span>
<span class='covered'>   *</span>
<span class='covered'>   *     // simple boolean defaulting to false</span>
<span class='covered'>   *     program.option('-C, --no-cheese', 'remove cheese');</span>
<span class='covered'>   *</span>
<span class='covered'>   *     program.cheese</span>
<span class='covered'>   *     // => true</span>
<span class='covered'>   *</span>
<span class='covered'>   *     --no-cheese</span>
<span class='covered'>   *     program.cheese</span>
<span class='covered'>   *     // => true</span>
<span class='covered'>   *</span>
<span class='covered'>   *     // required argument</span>
<span class='covered'>   *     program.option('-C, --chdir <path>', 'change the working directory');</span>
<span class='covered'>   *</span>
<span class='covered'>   *     --chdir /tmp</span>
<span class='covered'>   *     program.chdir</span>
<span class='covered'>   *     // => "/tmp"</span>
<span class='covered'>   *</span>
<span class='covered'>   *     // optional argument</span>
<span class='covered'>   *     program.option('-c, --cheese [type]', 'add cheese [marble]');</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} flags</span>
<span class='covered'>   * @param {String} description</span>
<span class='covered'>   * @param {Function|Mixed} fn or default</span>
<span class='covered'>   * @param {Mixed} defaultValue</span>
<span class='covered'>   * @return {Command} for chaining</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.option = function(flags, description, fn, defaultValue){</span>
<span class='covered'>    var self = this</span>
<span class='covered'>      , option = new Option(flags, description)</span>
<span class='covered'>      , oname = option.name()</span>
<span class='covered'>      , name = camelcase(oname);</span>
<span class='covered'>  </span>
<span class='covered'>    // default as 3rd arg</span>
<span class='covered'>    if ('function' != typeof fn) defaultValue = fn, fn = null;</span>
<span class='covered'>  </span>
<span class='covered'>    // preassign default value only for --no-*, [optional], or <required></span>
<span class='covered'>    if (false == option.bool || option.optional || option.required) {</span>
<span class='covered'>      // when --no-* we make sure default is true</span>
<span class='covered'>      if (false == option.bool) defaultValue = true;</span>
<span class='covered'>      // preassign only if we have a default</span>
<span class='covered'>      if (undefined !== defaultValue) self[name] = defaultValue;</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    // register the option</span>
<span class='covered'>    this.options.push(option);</span>
<span class='covered'>  </span>
<span class='covered'>    // when it's passed assign the value</span>
<span class='covered'>    // and conditionally invoke the callback</span>
<span class='covered'>    this.on(oname, function(val){</span>
<span class='covered'>      // coercion</span>
<span class='covered'>      if (null != val && fn) val = fn(val);</span>
<span class='covered'>  </span>
<span class='covered'>      // unassigned or bool</span>
<span class='covered'>      if ('boolean' == typeof self[name] || 'undefined' == typeof self[name]) {</span>
<span class='covered'>        // if no value, bool true, and we have a default, then use it!</span>
<span class='covered'>        if (null == val) {</span>
<span class='covered'>          self[name] = option.bool</span>
<span class='covered'>            ? defaultValue || true</span>
<span class='covered'>            : false;</span>
<span class='covered'>        } else {</span>
<span class='covered'>          self[name] = val;</span>
<span class='covered'>        }</span>
<span class='covered'>      } else if (null !== val) {</span>
<span class='covered'>        // reassign</span>
<span class='covered'>        self[name] = val;</span>
<span class='covered'>      }</span>
<span class='covered'>    });</span>
<span class='covered'>  </span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Parse `argv`, settings options and invoking commands when defined.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Array} argv</span>
<span class='covered'>   * @return {Command} for chaining</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.parse = function(argv){</span>
<span class='covered'>    // store raw args</span>
<span class='covered'>    this.rawArgs = argv;</span>
<span class='covered'>  </span>
<span class='covered'>    // guess name</span>
<span class='covered'>    if (!this.name) this.name = basename(argv[1]);</span>
<span class='covered'>  </span>
<span class='covered'>    // process argv</span>
<span class='covered'>    this.args = this.parseOptions(this.normalize(argv));</span>
<span class='covered'>    return this.parseArgs(this.args);</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Normalize `args`, splitting joined short flags. For example</span>
<span class='covered'>   * the arg "-abc" is equivalent to "-a -b -c".</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Array} args</span>
<span class='covered'>   * @return {Array}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.normalize = function(args){</span>
<span class='covered'>    var ret = []</span>
<span class='covered'>      , arg;</span>
<span class='covered'>  </span>
<span class='covered'>    for (var i = 0, len = args.length; i < len; ++i) {</span>
<span class='covered'>      arg = args[i];</span>
<span class='covered'>      if (arg.length > 1 && '-' == arg[0] && '-' != arg[1]) {</span>
<span class='uncovered'>        arg.slice(1).split('').forEach(function(c){</span>
<span class='uncovered'>          ret.push('-' + c);</span>
<span class='uncovered'>        });</span>
<span class='covered'>      } else {</span>
<span class='covered'>        ret.push(arg);</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    return ret;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Parse command `args`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * When listener(s) are available those</span>
<span class='covered'>   * callbacks are invoked, otherwise the "*"</span>
<span class='covered'>   * event is emitted and those actions are invoked.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Array} args</span>
<span class='covered'>   * @return {Command} for chaining</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.parseArgs = function(args){</span>
<span class='covered'>    var cmds = this.commands</span>
<span class='covered'>      , len = cmds.length</span>
<span class='covered'>      , name;</span>
<span class='covered'>  </span>
<span class='covered'>    if (args.length) {</span>
<span class='uncovered'>      name = args[0];</span>
<span class='covered'>      if (this.listeners(name).length) {</span>
<span class='uncovered'>        this.emit(args.shift(), args);</span>
<span class='covered'>      } else {</span>
<span class='uncovered'>        this.emit('*', args);</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Return an option matching `arg` if any.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} arg</span>
<span class='covered'>   * @return {Option}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.optionFor = function(arg){</span>
<span class='covered'>    for (var i = 0, len = this.options.length; i < len; ++i) {</span>
<span class='covered'>      if (this.options[i].is(arg)) {</span>
<span class='covered'>        return this.options[i];</span>
<span class='covered'>      }</span>
<span class='covered'>    }</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Parse options from `argv` returning `argv`</span>
<span class='covered'>   * void of these options.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Array} argv</span>
<span class='covered'>   * @return {Array}</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.parseOptions = function(argv){</span>
<span class='covered'>    var args = []</span>
<span class='covered'>      , argv = argv.slice(2)</span>
<span class='covered'>      , len = argv.length</span>
<span class='covered'>      , option</span>
<span class='covered'>      , arg;</span>
<span class='covered'>  </span>
<span class='covered'>    // parse options</span>
<span class='covered'>    for (var i = 0; i < len; ++i) {</span>
<span class='covered'>      arg = argv[i];</span>
<span class='covered'>      option = this.optionFor(arg);</span>
<span class='covered'>  </span>
<span class='covered'>      // option is defined</span>
<span class='covered'>      if (option) {</span>
<span class='covered'>        // requires arg</span>
<span class='covered'>        if (option.required) {</span>
<span class='covered'>          arg = argv[++i];</span>
<span class='partial'>          if (null == arg) return <span class='partialuncovered'>  this.optionMissingArgument(option)</span>;</span>
<span class='partial'>          if ('-' == arg[0]) return <span class='partialuncovered'>  this.optionMissingArgument(option, arg)</span>;</span>
<span class='covered'>          this.emit(option.name(), arg);</span>
<span class='covered'>        // optional arg</span>
<span class='covered'>        } else if (option.optional) {</span>
<span class='uncovered'>          arg = argv[i+1];</span>
<span class='uncovered'>          if (null == arg || '-' == arg[0]) {</span>
<span class='uncovered'>            arg = null;</span>
<span class='covered'>          } else {</span>
<span class='uncovered'>            ++i;</span>
<span class='covered'>          }</span>
<span class='uncovered'>          this.emit(option.name(), arg);</span>
<span class='covered'>        // bool</span>
<span class='covered'>        } else {</span>
<span class='covered'>          this.emit(option.name());</span>
<span class='covered'>        }</span>
<span class='covered'>        continue;</span>
<span class='covered'>      }</span>
<span class='covered'>      </span>
<span class='covered'>      // looks like an option</span>
<span class='uncovered'>      if (arg.length > 1 && '-' == arg[0]) {</span>
<span class='uncovered'>        this.unknownOption(arg);</span>
<span class='covered'>      }</span>
<span class='covered'>      </span>
<span class='covered'>      // arg</span>
<span class='uncovered'>      args.push(arg);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='covered'>    return args;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Argument `name` is missing.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} name</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.missingArgument = function(name){</span>
<span class='uncovered'>    console.error();</span>
<span class='uncovered'>    console.error("  error: missing required argument `%s'", name);</span>
<span class='uncovered'>    console.error();</span>
<span class='uncovered'>    process.exit(1);</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * `Option` is missing an argument, but received `flag` or nothing.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} option</span>
<span class='covered'>   * @param {String} flag</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.optionMissingArgument = function(option, flag){</span>
<span class='uncovered'>    console.error();</span>
<span class='covered'>    if (flag) {</span>
<span class='uncovered'>      console.error("  error: option `%s' argument missing, got `%s'", option.flags, flag);</span>
<span class='covered'>    } else {</span>
<span class='uncovered'>      console.error("  error: option `%s' argument missing", option.flags);</span>
<span class='covered'>    }</span>
<span class='uncovered'>    console.error();</span>
<span class='uncovered'>    process.exit(1);</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Unknown option `flag`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} flag</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.unknownOption = function(flag){</span>
<span class='uncovered'>    console.error();</span>
<span class='uncovered'>    console.error("  error: unknown option `%s'", flag);</span>
<span class='uncovered'>    console.error();</span>
<span class='uncovered'>    process.exit(1);</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Set the program version to `str`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * This method auto-registers the "-V, --version" flag</span>
<span class='covered'>   * which will print the version number when passed.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {String} flags</span>
<span class='covered'>   * @return {Command} for chaining</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.version = function(str, flags){</span>
<span class='covered'>    if (0 == arguments.length) return this._version;</span>
<span class='covered'>    this._version = str;</span>
<span class='covered'>    flags = flags || '-V, --version';</span>
<span class='covered'>    this.option(flags, 'output the version number');</span>
<span class='covered'>    this.on('version', function(){</span>
<span class='uncovered'>      console.log(str);</span>
<span class='uncovered'>      process.exit(0);</span>
<span class='covered'>    });</span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Set the description `str`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @return {String|Command}</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.description = function(str){</span>
<span class='uncovered'>    if (0 == arguments.length) return this._description;</span>
<span class='uncovered'>    this._description = str;</span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Set / get the command usage `str`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @return {String|Command}</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.usage = function(str){</span>
<span class='covered'>    var usage = '[options'</span>
<span class='covered'>      + (this.commands.length ? '] [command' : '')</span>
<span class='covered'>      + ']';</span>
<span class='partial'>    if (0 == arguments.length) return <span class='partialuncovered'>  this._usage || u</span>sage;</span>
<span class='covered'>    this._usage = str;</span>
<span class='covered'>    return this;</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Return the largest option length.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @return {Number}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.largestOptionLength = function(){</span>
<span class='uncovered'>    return this.options.reduce(function(max, option){</span>
<span class='uncovered'>      return Math.max(max, option.flags.length);</span>
<span class='uncovered'>    }, 0);</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Return help for options.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @return {String}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.optionHelp = function(){</span>
<span class='uncovered'>    var width = this.largestOptionLength();</span>
<span class='uncovered'>    return this.options.map(function(option){</span>
<span class='uncovered'>      return pad(option.flags, width)</span>
<span class='uncovered'>        + '  ' + option.description;</span>
<span class='uncovered'>    }).join('\n');</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Return command help documentation.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @return {String}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.commandHelp = function(){</span>
<span class='uncovered'>    if (!this.commands.length) return '';</span>
<span class='uncovered'>    return [</span>
<span class='uncovered'>        ''</span>
<span class='uncovered'>      , '  Commands:'</span>
<span class='uncovered'>      , ''</span>
<span class='uncovered'>      , this.commands.map(function(cmd){</span>
<span class='uncovered'>        var args = cmd.args.map(function(arg){</span>
<span class='uncovered'>          return arg.required</span>
<span class='uncovered'>            ? '&lt;' + arg.name + '>'</span>
<span class='uncovered'>            : '[' + arg.name + ']';</span>
<span class='uncovered'>        }).join(' ');</span>
<span class='uncovered'>        return cmd.name + ' ' + args</span>
<span class='uncovered'>          + (cmd.description()</span>
<span class='uncovered'>            ? '\n' + cmd.description()</span>
<span class='uncovered'>            : '');</span>
<span class='uncovered'>      }).join('\n\n').replace(/^/gm, '    ')</span>
<span class='uncovered'>      , ''</span>
<span class='uncovered'>    ].join('\n');</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Return program help documentation.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @return {String}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.helpInformation = function(){</span>
<span class='uncovered'>    return [</span>
<span class='uncovered'>        ''</span>
<span class='uncovered'>      , '  Usage: ' + this.name + ' ' + this.usage()</span>
<span class='uncovered'>      , '' + this.commandHelp()</span>
<span class='uncovered'>      , '  Options:'</span>
<span class='uncovered'>      , ''</span>
<span class='uncovered'>      , '' + this.optionHelp().replace(/^/gm, '    ')</span>
<span class='uncovered'>      , ''</span>
<span class='uncovered'>      , ''</span>
<span class='uncovered'>    ].join('\n');</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Prompt for a `Number`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.promptForNumber = function(str, fn){</span>
<span class='uncovered'>    this.promptSingleLine(str, function(val){</span>
<span class='uncovered'>      val = Number(val);</span>
<span class='uncovered'>      if (isNaN(val)) return program.promptForNumber(str + '(must be a number) ', fn);</span>
<span class='uncovered'>      fn(val);</span>
<span class='uncovered'>    });</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Prompt for a `Date`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.promptForDate = function(str, fn){</span>
<span class='uncovered'>    this.promptSingleLine(str, function(val){</span>
<span class='uncovered'>      val = new Date(val);</span>
<span class='uncovered'>      if (isNaN(val.getTime())) return program.promptForDate(str + '(must be a date) ', fn);</span>
<span class='uncovered'>      fn(val);</span>
<span class='uncovered'>    });</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Single-line prompt.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.promptSingleLine = function(str, fn){</span>
<span class='uncovered'>    if ('function' == typeof arguments[2]) {</span>
<span class='uncovered'>      return this['promptFor' + (fn.name || fn)](str, arguments[2]);</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    process.stdout.write(str);</span>
<span class='uncovered'>    process.stdin.setEncoding('utf8');</span>
<span class='uncovered'>    process.stdin.once('data', function(val){</span>
<span class='uncovered'>      fn(val);</span>
<span class='uncovered'>    }).resume();</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Multi-line prompt.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.promptMultiLine = function(str, fn){</span>
<span class='uncovered'>    var buf = '';</span>
<span class='uncovered'>    console.log(str);</span>
<span class='uncovered'>    process.stdin.setEncoding('utf8');</span>
<span class='uncovered'>    process.stdin.on('data', function(val){</span>
<span class='uncovered'>      if ('\n' == val) {</span>
<span class='uncovered'>        process.stdin.removeAllListeners('data');</span>
<span class='uncovered'>        fn(buf);</span>
<span class='uncovered'>      } else {</span>
<span class='uncovered'>        buf += val;</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>    }).resume();</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Prompt `str` and callback `fn(val)`</span>
<span class='covered'>   *</span>
<span class='covered'>   * Commander supports single-line and multi-line prompts.</span>
<span class='covered'>   * To issue a single-line prompt simply add white-space</span>
<span class='covered'>   * to the end of `str`, something like "name: ", whereas</span>
<span class='covered'>   * for a multi-line prompt omit this "description:".</span>
<span class='covered'>   *</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *     program.prompt('Username: ', function(name){</span>
<span class='covered'>   *       console.log('hi %s', name);</span>
<span class='covered'>   *     });</span>
<span class='covered'>   *     </span>
<span class='covered'>   *     program.prompt('Description:', function(desc){</span>
<span class='covered'>   *       console.log('description was "%s"', desc.trim());</span>
<span class='covered'>   *     });</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.prompt = function(str, fn){</span>
<span class='uncovered'>    if (/ $/.test(str)) return this.promptSingleLine.apply(this, arguments);</span>
<span class='uncovered'>    this.promptMultiLine(str, fn);</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Prompt for password with `str`, `mask` char and callback `fn(val)`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * The mask string defaults to '', aka no output is</span>
<span class='covered'>   * written while typing, you may want to use "*" etc.</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *     program.password('Password: ', function(pass){</span>
<span class='covered'>   *       console.log('got "%s"', pass);</span>
<span class='covered'>   *       process.stdin.destroy();</span>
<span class='covered'>   *     });</span>
<span class='covered'>   *</span>
<span class='covered'>   *     program.password('Password: ', '*', function(pass){</span>
<span class='covered'>   *       console.log('got "%s"', pass);</span>
<span class='covered'>   *       process.stdin.destroy();</span>
<span class='covered'>   *     });</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {String} mask</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.password = function(str, mask, fn){</span>
<span class='uncovered'>    var self = this</span>
<span class='uncovered'>      , buf = '';</span>
<span class='covered'>  </span>
<span class='covered'>    // default mask</span>
<span class='uncovered'>    if ('function' == typeof mask) {</span>
<span class='uncovered'>      fn = mask;</span>
<span class='uncovered'>      mask = '';</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    tty.setRawMode(true);</span>
<span class='uncovered'>    process.stdout.write(str);</span>
<span class='covered'>  </span>
<span class='covered'>    // keypress</span>
<span class='uncovered'>    process.stdin.on('keypress', function(c, key){</span>
<span class='uncovered'>      if (key && 'enter' == key.name) {</span>
<span class='uncovered'>        console.log();</span>
<span class='uncovered'>        process.stdin.removeAllListeners('keypress');</span>
<span class='uncovered'>        tty.setRawMode(false);</span>
<span class='uncovered'>        if (!buf.trim().length) return self.password(str, mask, fn);</span>
<span class='uncovered'>        fn(buf);</span>
<span class='uncovered'>        return;</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>  </span>
<span class='uncovered'>      if (key && key.ctrl && 'c' == key.name) {</span>
<span class='uncovered'>        console.log('%s', buf);</span>
<span class='uncovered'>        process.exit();</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>  </span>
<span class='uncovered'>      process.stdout.write(mask);</span>
<span class='uncovered'>      buf += c;</span>
<span class='uncovered'>    }).resume();</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Confirmation prompt with `str` and callback `fn(bool)`</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *      program.confirm('continue? ', function(ok){</span>
<span class='covered'>   *        console.log(' got %j', ok);</span>
<span class='covered'>   *        process.stdin.destroy();</span>
<span class='covered'>   *      });</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.confirm = function(str, fn){</span>
<span class='uncovered'>    var self = this;</span>
<span class='uncovered'>    this.prompt(str, function(ok){</span>
<span class='uncovered'>      if (!ok.trim()) {</span>
<span class='uncovered'>        return self.confirm(str, fn);</span>
<span class='uncovered'>      }</span>
<span class='uncovered'>      fn(parseBool(ok));</span>
<span class='uncovered'>    });</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Choice prompt with `list` of items and callback `fn(index, item)`</span>
<span class='covered'>   *</span>
<span class='covered'>   * Examples:</span>
<span class='covered'>   *</span>
<span class='covered'>   *      var list = ['tobi', 'loki', 'jane', 'manny', 'luna'];</span>
<span class='covered'>   *      </span>
<span class='covered'>   *      console.log('Choose the coolest pet:');</span>
<span class='covered'>   *      program.choose(list, function(i){</span>
<span class='covered'>   *        console.log('you chose %d "%s"', i, list[i]);</span>
<span class='covered'>   *        process.stdin.destroy();</span>
<span class='covered'>   *      });</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {Array} list</span>
<span class='covered'>   * @param {Function} fn</span>
<span class='covered'>   * @api public</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  Command.prototype.choose = function(list, fn){</span>
<span class='uncovered'>    var self = this;</span>
<span class='covered'>  </span>
<span class='uncovered'>    list.forEach(function(item, i){</span>
<span class='uncovered'>      console.log('  %d) %s', i + 1, item);</span>
<span class='uncovered'>    });</span>
<span class='covered'>  </span>
<span class='covered'>    function again() {</span>
<span class='uncovered'>      self.prompt('  : ', function(val){</span>
<span class='uncovered'>        val = parseInt(val, 10) - 1;</span>
<span class='uncovered'>        if (null == list[val]) {</span>
<span class='uncovered'>          again();</span>
<span class='uncovered'>        } else {</span>
<span class='uncovered'>          fn(val, list[val]);</span>
<span class='uncovered'>        }</span>
<span class='uncovered'>      });</span>
<span class='covered'>    }</span>
<span class='covered'>  </span>
<span class='uncovered'>    again();</span>
<span class='covered'>  };</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Camel-case the given `flag`</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} flag</span>
<span class='covered'>   * @return {String}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  function camelcase(flag) {</span>
<span class='covered'>    return flag.split('-').reduce(function(str, word){</span>
<span class='partial'>      return str + <span class='partialuncovered'>  word[0].toUpperCase()</span> + word.slice(1);</span>
<span class='covered'>    });</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Parse a boolean `str`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @return {Boolean}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  function parseBool(str) {</span>
<span class='uncovered'>    return /^y|yes|ok|true$/i.test(str);</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Pad `str` to `width`.</span>
<span class='covered'>   *</span>
<span class='covered'>   * @param {String} str</span>
<span class='covered'>   * @param {Number} width</span>
<span class='covered'>   * @return {String}</span>
<span class='covered'>   * @api private</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  function pad(str, width) {</span>
<span class='uncovered'>    var len = Math.max(0, width - str.length);</span>
<span class='uncovered'>    return str + Array(len + 1).join(' ');</span>
<span class='covered'>  }</span>
<span class='covered'>  </span>
<span class='covered'>  /**</span>
<span class='covered'>   * Default -h, --help option.</span>
<span class='covered'>   */</span>
<span class='covered'>  </span>
<span class='covered'>  exports.option('-h, --help', 'output usage information');</span>
<span class='covered'>  exports.on('help', function(){</span>
<span class='uncovered'>    process.stdout.write(this.helpInformation());</span>
<span class='uncovered'>    exports.emit('--help');</span>
<span class='uncovered'>    process.exit(0);</span>
<span class='covered'>  });</span>
<span class='covered'>  </span>
</pre>
        <a class="index" href="index.html">Â« index</a> | <a class="coverio" href="http://cover.io">cover.io</a>
      </div>
  </body>
</html>
